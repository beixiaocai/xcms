<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{% if  "add" == handle %}添加布控算法{% else %}编辑布控算法{% endif %}</title>
    
    <!-- Font Awesome -->
    <link href="/static/vendors/font-awesome/css/font-awesome.min.css" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f8f9fa;
            color: #333;
        }
        
        .container {
            width: 100%;
            padding: 20px;
        }
        
        .page-header {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .page-header h2 {
            font-size: 20px;
            font-weight: 600;
            color: #374151;
        }
        
        .content-wrapper {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .video-section {
            flex: 1.4;
            min-width: 400px;
        }
        
        .form-section {
            flex: 0.8;
            min-width: 300px;
        }
        
        .div_canvas_box {
            background: #e5e5e5;
            display: block;
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 比例 */
            overflow: hidden;
            border-radius: 8px;
        }
        
        .div_canvas_box>div {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .div_canvas_box>canvas {
            margin: 0;
            border: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 6;
        }
        
        .div_left_bottom_menu {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #e5e7eb;
            background-color: #ffffff;
            border-radius: 6px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .btn {
            border-radius: 4px;
            font-size: 14px;
            padding: 6px 12px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }
        
        .btn-dark {
            background-color: #374151;
            color: white;
        }
        
        .btn-dark:hover {
            background-color: #1f2937;
        }
        
        .btn-default {
            background-color: #f3f4f6;
            color: #374151;
            border-color: #d1d5db;
        }
        
        .btn-default:hover {
            background-color: #e5e7eb;
        }
        
        .btn-group {
            display: flex;
            gap: 5px;
        }
        
        .form-horizontal {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .form-group {
            margin-bottom: 10px;
        }
        
        .control-label {
            font-weight: 500;
            font-size: 14px;
            color: #374151;
            margin-bottom: 5px;
            display: block;
        }
        
        .required {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        
        .form-control:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .select2_single {
            width: 100%;
        }
        
        .ln_solid {
            border-top: 1px solid #e5e7eb;
            margin: 20px 0;
        }
        
        textarea.form-control {
            resize: vertical;
            min-height: 80px;
        }
        
        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .content-wrapper {
                flex-direction: column;
            }
            
            .video-section,
            .form-section {
                flex: 1;
                min-width: 100%;
            }
            
            .div_left_bottom_menu {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn-group {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
    <!--
        <div class="page-header">
            <h2><i class="fa fa-plus-circle"></i> {% if  "add" == handle %}添加布控算法{% else %}编辑布控算法{% endif %}</h2>
        </div>
        -->
        
        <div class="content-wrapper">
            <!-- 视频播放器和Canvas区域 -->
            <div class="video-section">
                <div class="div_canvas_box">
                    <div id="video_player" style="background-color: black;aspect-ratio: 16 / 9;">
                    </div>
                   <canvas id="canvas" >
                        Your browser is too old which doesn't support h5 canvas
                   </canvas>
                </div>

                <div class="div_left_bottom_menu">
                    <button type="button" onclick="f_clickPlayStart()" class="btn btn-dark"><i class="fa fa-play"></i> 播放</button>
                    <button type="button" onclick="f_clickPlayStop()" class="btn btn-default"><i class="fa fa-stop"></i> 停止</button>
                    <button type="button" onclick="f_clearVideoCanvas()" class="btn btn-default"><i class="fa fa-paint-brush"></i> 清空区域</button>
                    <div class="btn-group">
                        <button type="button" id="btn_draw_type1" class="btn btn-default">矩形</button>
                        <button type="button" id="btn_draw_type2" class="btn btn-default">多边形</button>
                        <button type="button" id="btn_draw_type4" class="btn btn-default">方向线</button>
                    </div>
                </div>
            </div>

            <!-- 表单区域 -->
            <div class="form-section">
                <form class="form-horizontal">
                    <div class="form-group">
                        <label class="control-label">布控编号</label>
                        <span style="height: 34px;line-height: 34px;padding: 6px 0;">{{ controlAlgorithm.control_code }}</span>
                    </div>

                    <div class="form-group">
                        <label class="control-label">布控算法编号</label>
                        <span style="height: 34px;line-height: 34px;padding: 6px 0;">{{ controlAlgorithm.code }}</span>
                    </div>

                    <div class="form-group">
                        <label class="control-label">播放地址</label>
                        <input id="input_video_url" type="url" disabled="disabled" class="form-control">
                    </div>

                    <div class="ln_solid"></div>

                    <div class="form-group">
                        <label class="control-label">业务算法 <span class="required">*</span></label>
                        <select id="select_flow" class="form-control" required="required">
                            <option value="0">请选择业务算法</option>
                            {% for flow in flows %}
                                <option {% if flow.code == controlAlgorithm.flow_code %} selected {% endif %} value="{{ flow.code }}">{{ flow.name }}</option>
                            {% endfor %}
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="control-label">大模型复核</label>
                        <select id="select_llm" class="form-control">
                            <option value="">请选择大模型</option>
                            {% for llm in llms %}
                                <option {% if llm.code == controlAlgorithm.llm_code %} selected {% endif %} value="{{ llm.code }}">{{ llm.name }}</option>
                            {% endfor %}
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="control-label">大模型提示词</label>
                        <textarea rows="1" id="input_llm_prompt" class="form-control" style="height: 40px; min-height: 40px;">{{ controlAlgorithm.llm_prompt }}</textarea>
                    </div>

                    <div class="form-group">
                        <label class="control-label">发生关键词</label>
                        <input type="text" id="input_llm_happen_words" class="form-control" value="{{ controlAlgorithm.llm_happen_words }}">
                    </div>
                    <!--
                    <div class="form-group">
                        <label class="control-label">扩展参数</label>
                        <textarea rows="3" name="extend_params" class="form-control">{{ controlAlgorithm.extend_params }}</textarea>
                    </div>-->

                    <div class="ln_solid"></div>

                    <div class="form-actions">
                        <button type="button" onclick="if(window.parent && window.parent.closeAlgorithmModal){window.parent.closeAlgorithmModal();}else{window.history.go(-1);}" class="btn btn-default">取消</button>
                        <button type="button" onclick="f_openHandle()" class="btn btn-dark">提交</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- jQuery -->
    <script src="/static/lib/jquery/jquery.min.js"></script>
    <!-- easyPlayer -->
    <script src="/static/lib/easyPlayer/js/easyplayer-pro.js?02"></script>
    <!-- canvas-select -->
    <script src="/static/vendors/canvas_select/canvas-select.min.js"></script>
    <!-- toast -->
    <script src="/static/app/common/js/toast.js"></script>

    <script>

        let flowDict = {};//算法字典
        let flowCode;

        // 初始化数据字典
        $(function() {

            // 初始化算法字典
            {% for flow in flows %}
                flowDict['{{ flow.code }}'] = {
                    "code": '{{ flow.code }}',
                    "name": '{{ flow.name }}'
                };
            {% endfor %}
        });

        let controlAlgorithmCode= '{{ controlAlgorithm.code }}';// 布控算法编号
        let controlCode= '{{ controlAlgorithm.control_code }}';// 布控编号
        let mPolygon = '{{ controlAlgorithm.polygon }}';// 算法识别区域
        let mPolygonType = parseInt('{{ controlAlgorithm.polygon_type }}');// string类型->int 0:未绘制 1:矩形 2:方向线 3:多边形
        if(isNaN(mPolygonType)){
            mPolygonType = 1;//默认是矩形类型
        }
        let handle = '{{ handle }}';// 操作类型 add 或 edit
        let eleDivCanvasBox=document.querySelector('.div_canvas_box')
        let eleVideoPlayer = document.querySelector('#video_player');
        let mVideoUrl = null;
        let eleInputVideoUrl= $("#input_video_url");// input
        let eleSelectFlow = $("#select_flow");// select 算法

        //let eleTextareaExtendParams = $("textarea[name='extend_params']");

        let eleBtnDrawType1 = $("#btn_draw_type1");
        let eleBtnDrawType2 = $("#btn_draw_type2");
        let eleBtnDrawType4 = $("#btn_draw_type4");

        let eleCanvas=document.getElementById("canvas");
        // 修复变量名错误，正确设置canvas的实际像素大小
        eleCanvas.width= eleVideoPlayer.clientWidth
        eleCanvas.height = eleVideoPlayer.clientHeight
        let instance = new CanvasSelect("#canvas", eleCanvas.toDataURL());

        console.log("eleVideoPlayer.clientWidth:",eleVideoPlayer.clientWidth)
        console.log("eleVideoPlayer.clientHeight:",eleVideoPlayer.clientHeight)

        let option = [];
        instance.labelMaxLen = 10;
        //   instance.setData(option);
        function f_changeCreateType(createType) {
            console.log("f_changeCreateType->",createType)
            instance.createType = createType; // 0 不创建(默认)，1创建矩形，2创建多边形，3点标注，4折线标注，5圆形标注，6网格标注
            if(createType === 1){
                mPolygonType = 1;//矩形
            }else if(createType === 2){
                mPolygonType = 3;//多边形
            }else if(createType === 4 || createType === 6){
                mPolygonType = 2;//方向线
            }else{
                mPolygonType = 0;//未绘制或不支持的绘制类型
            }

            //调整显示按钮
            if(mPolygonType===1){
                eleBtnDrawType1.removeClass("btn-default").addClass("btn-dark");
                eleBtnDrawType2.removeClass("btn-dark").addClass("btn-default");
                eleBtnDrawType4.removeClass("btn-dark").addClass("btn-default");
            }else if(mPolygonType === 3){
                eleBtnDrawType1.removeClass("btn-dark").addClass("btn-default");
                eleBtnDrawType2.removeClass("btn-default").addClass("btn-dark");
                eleBtnDrawType4.removeClass("btn-dark").addClass("btn-default");
            }else if(mPolygonType === 2){
                eleBtnDrawType1.removeClass("btn-dark").addClass("btn-default");
                eleBtnDrawType2.removeClass("btn-dark").addClass("btn-default");
                eleBtnDrawType4.removeClass("btn-default").addClass("btn-dark");
            }
        }

        eleBtnDrawType1.click(function () {
            f_changeCreateType(1);
        })
        eleBtnDrawType2.click(function () {
            f_changeCreateType(2);
        })
        eleBtnDrawType4.click(function () {
            f_changeCreateType(4);
        })

        instance.on("load", (src) => {
        });
        // 添加
        instance.on("add", (info) => {
            console.log("add->info.type",info.type);
            if(info.type === 1){//绘制矩形，支持多个矩形
                option.push(info);
            }else if(info.type === 2){//绘制多边形，支持多个多边形
                option.push(info);
            }else if(info.type === 4 || info.type === 6){//绘制方向线，仅支持绘制一个方向线
                if(option.length > 0){
                    if(option[0].type === 4){//第一个图形必须是类型4
                    }else{
                        f_clearVideoCanvas();
                        f_changeCreateType(4);
                        alert("绘制类型不正确，请重试");
                        return;
                    }
                }
                if (info.type === 4) {
                    f_changeCreateType(6)
                }
                option.push(info);
                let info_type = info.type.toString();
                if (option.length === 2) {
                    if(info.type === 6) {
                        let ind = option.length
                        let line = option[ind - 2] // 拿到直线
                        let res = f_calcuTwoLineIntersect(line.coor[0], line.coor[1], info.coor[0], info.coor[1]);
                        if (!res) {
                            alert("方向线交叉不合规c1-"+info_type);
                            option.pop()
                            instance.setData(option);

                        }
                    }else{
                        f_clearVideoCanvas();
                        f_changeCreateType(4);
                        alert("方向线类型不合规c1-"+info_type);
                    }
                } else if (option.length === 3) {
                    if (info.type === 6) {
                        let ind = option.length
                        let line = option[ind - 2] // 拿到直线
                        let res = f_calcuTwoLineIntersect(line.coor[0], line.coor[1], info.coor[0], info.coor[1]);
                        if (!res) {
                            alert("方向线交叉不合规c2-"+info_type);
                            option.pop()
                            instance.setData(option);

                        }
                    } else {
                        f_clearVideoCanvas();
                        f_changeCreateType(4);
                        alert("方向线类型不合规c2-"+info_type);
                    }
                }
            }
        });
        // 删除
        instance.on("delete", (info) => {
            window.info = info;
        });
        // 选中
        instance.on("select", (shape) => {
            window.shape = shape;
        });
        instance.on("updated", (result) => {
          //   myToast2025("请选择视频流", "error");
            const list = [...result];

            list.sort((a, b) => a.index - b.index);
        });


        //清空绘制区域数据
        function f_clearVideoCanvas() {
            console.log("f_clearVideoCanvas() 执行清空绘制区域数据");
            console.log("instance:",instance)

            option = [];
            instance.setData(option);

        }
        //窗口对齐
        function f_adjustVideoCanvas() {
            console.log("f_adjustVideoCanvas() 执行canvas与播放器对齐");
            //执行窗口对齐以后，此前的绘制区域数据，可能不在对应，因此需要刷新
            let w = eleVideoPlayer.offsetWidth;
            let h = eleVideoPlayer.offsetHeight;
            //console.log("eleVideoPlayer.offsetWidth:",eleVideoPlayer.offsetWidth)
            //console.log("eleVideoPlayer.offsetHeight:",eleVideoPlayer.offsetHeight)
            
            // 同时设置canvas的样式大小和实际像素大小
            eleCanvas.style.width = String(w)+"px";
            eleCanvas.style.height = String(h)+"px";
            eleCanvas.width = w;
            eleCanvas.height = h;
            
            instance.setData(option);
            
        }
        //计算两条直线是否相交
        function f_calcuTwoLineIntersect(p1, q1, p2, q2) {
            // 计算直线1和直线2的a, b, c
            const a1 = q1[1] - p1[1];
            const b1 = p1[0] - q1[0];
            const c1 = a1 * p1[0] + b1 * p1[1];

            const a2 = q2[1] - p2[1];
            const b2 = p2[0] - q2[0];
            const c2 = a2 * p2[0] + b2 * p2[1];

            // 计算行列式
            const det = a1 * b2 - a2 * b1;

            // 没有交点
            if (det === 0) {
                return false;
            }

            // 计算交点坐标
            const x = (b2 * c1 - b1 * c2) / det;
            const y = (a1 * c2 - a2 * c1) / det;

            // 检查交点是否在两条线的段上
            return (
                (p1[0] <= x && x <= q1[0] && p2[0] <= x && x <= q2[0]) ||
                (p1[0] >= x && x >= q1[0] && p2[0] >= x && x >= q2[0]) ||
                (p1[1] <= y && y <= q1[1] && p2[1] <= y && y <= q2[1]) ||
                (p1[1] >= y && y >= q1[1] && p2[1] >= y && y >= q2[1])
            );
        }

        let ePlayer = null;
        function f_createEPlayer() {
            ePlayer = new EasyPlayerPro({
                container: eleVideoPlayer,
                videoBuffer: 0.1, // 缓存时长
                videoBufferDelay: Number(3), // 1000s 达到延迟重播(s)
                decoder: '/static/lib/easyPlayer/js/decoder-pro.js',
                isResize: true,
                text: "北小菜",
                loadingText: "加载中",
                debug: false,
                debugLevel: "debug",
                useMSE: true,
                useSIMD: false,
                useWCS: true,
                hasAudio: true,
                websocket1006ErrorReplay: true,
                networkDelayTimeoutReplay: true,
                useMThreading: true,
                showBandwidth: false, // 显示网速
                showPerformance: false, // 显示性能
                operateBtns: {
                    fullscreen: false,
                    screenshot: false,
                    play: true,
                    audio: false,
                    ptz: false,
                    quality: false,
                    performance: false,
                },
                background: "/static/images/player_poster.jpg",
                timeout: 10,
                qualityConfig: ['普清', '高清', '超清'],
                forceNoOffscreen: true,
                isNotMute: false,
                heartTimeout: Number(7),//超出时间无数据重连(s)
                ptzClickType: 'mouseDownAndUp',
                ptzZoomShow: true,
                ptzMoreArrowShow: true,
                ptzApertureShow: true,
                ptzFocusShow: true,
                pauseAndNextPlayUseLastFrameShow: true,
                heartTimeoutReplayUseLastFrameShow: true,
                replayUseLastFrameShow: true, // 重播使用上一帧显示
                fullscreenWatermarkConfig: {
                    text: "", //水印
                }
            });
        }

        function f_playStart(video_url){
            if(video_url === "" || typeof video_url === "undefined"){
                myToast2025("请输入播放地址（支持ws-fmp4/http-fmp4）！","error");
                return false;
            }
            if(!video_url.endsWith(".mp4")){
                myToast2025("视频流地址格式不正确！","error");
                return false;
            }
            if(video_url.startsWith("ws://") || video_url.startsWith("http://")){
                if (ePlayer) {
                    ePlayer.destroy().then(() => {
                        f_createEPlayer();
                        ePlayer.play(video_url);
                    });
                } else {
                    f_createEPlayer();
                    ePlayer.play(video_url);
                }
                f_resetPolygon()
            }else{
                 myToast2025("视频流地址格式不正确！","error");
                 return false;
            }

        }
        function f_playStop(){
            if(ePlayer){
                //ePlayer.pause();
                ePlayer.destroy();
            }else{
                myToast2025("播放器未启动！","error");
            }
            f_clearVideoCanvas()

        }
        function f_clickPlayStart() {
            if(mVideoUrl){
                f_playStart(mVideoUrl);
                for (let i = 0; i < 10; i++) {
                    setTimeout(function () {
                        f_adjustVideoCanvas();
                    }, i*200);
                }
            }

        }
        function f_clickPlayStop() {
            f_playStop();
            f_adjustVideoCanvas();
        }
        function f_openHandle() {

            flowCode = eleSelectFlow.val().trim();//typeof string
            if(flowCode==="0"){
                myToast2025("请选择算法","error");
                return;
            }

            //let extend_params = eleTextareaExtendParams.val().trim();
            let llm_code = $('#select_llm').val().trim();
            let llm_prompt = $('#input_llm_prompt').val().trim();
            let llm_happen_words = $('#input_llm_happen_words').val().trim();

            //canvas绘制区域
            let canvas_box_width = eleDivCanvasBox.clientWidth;
            let canvas_box_height = eleDivCanvasBox.clientHeight

            console.log("canvas_box_width->",canvas_box_width)
            console.log("canvas_box_height->",canvas_box_height)
            console.log("canvas_width->",eleCanvas.width)
            console.log("canvas_height->",eleCanvas.height)
            console.log("option.length->",option.length,option)
            console.log("instance.createType->",instance.createType)
            console.log("mPolygonType->",mPolygonType)

            let polygon_array=[]
            if(mPolygonType === 1){//矩形
                if(option.length > 0){
                    for (let i = 0; i < option.length; i++) {
                        let info = option[i];
                        let topL = info.coor[0];
                        let botR = info.coor[1];
                        let topR = [botR[0], topL[1]];
                        let botL = [topL[0], botR[1]];
                        // 四个点
                        let item = []
                        item.push((topL[0]/canvas_box_width).toFixed(4));
                        item.push((topL[1]/canvas_box_height).toFixed(4));
                        item.push((topR[0]/canvas_box_width).toFixed(4));
                        item.push((topR[1]/canvas_box_height).toFixed(4));
                        item.push((botR[0]/canvas_box_width).toFixed(4));
                        item.push((botR[1]/canvas_box_height).toFixed(4));
                        item.push((botL[0]/canvas_box_width).toFixed(4));
                        item.push((botL[1]/canvas_box_height).toFixed(4));
                        polygon_array.push(item.join(","))
                    }
                }else{
                    //矩形未绘制->全屏
                    let item = []
                    item.push(0);
                    item.push(0);
                    item.push(0);
                    item.push(1);
                    item.push(1);
                    item.push(1);
                    item.push(1);
                    item.push(0);
                    polygon_array.push(item.join(","))
                }
            }else if(mPolygonType === 2){//方向线
                if(option.length === 2){
                    let info1 = option[0];
                    let info2 = option[1];
                    let topL= info1.coor[0];
                    let topR= info1.coor[1];
                    let botL= info2.coor[0];
                    let botR= info2.coor[1];
                      // 四个点
                    let item = []
                    item.push((topL[0] / canvas_box_width).toFixed(4));
                    item.push((topL[1] / canvas_box_height).toFixed(4));
                    item.push((topR[0] / canvas_box_width).toFixed(4));
                    item.push((topR[1] / canvas_box_height).toFixed(4));
                    item.push((botR[0] / canvas_box_width).toFixed(4));
                    item.push((botR[1] / canvas_box_height).toFixed(4));
                    item.push((botL[0] / canvas_box_width).toFixed(4));
                    item.push((botL[1] / canvas_box_height).toFixed(4));

                    polygon_array.push(item.join(","))
                }else{
                    myToast2025("方向线类型必须是两条直线","error");
                    return;
                }
            }else if(mPolygonType === 3){//多边形
                if(option.length > 0){
                    for (let i = 0; i < option.length; i++) {
                        let info = option[i];
                        // 至少3个点
                        let item = []
                        for (let j = 0; j < info.coor.length; j++) {
                            item.push((info.coor[j][0]/canvas_box_width).toFixed(4));
                            item.push((info.coor[j][1]/canvas_box_height).toFixed(4));
                        }
                        polygon_array.push(item.join(","))

                    }
                }else{
                    //多边形未绘制->全屏
                    let item = []
                    item.push(0);
                    item.push(0);
                    item.push(0);
                    item.push(1);
                    item.push(1);
                    item.push(1);
                    item.push(1);
                    item.push(0);
                    polygon_array.push(item.join(","))
                }
            }else{
                myToast2025("绘制类型错误:"+mPolygonType.toString(),"error");
                return;
            }
            console.log("polygon_array.length->",polygon_array.length)
            console.log("polygon_array->",polygon_array)
            
            let polygon = polygon_array.join("#");
            // 判断类型
            let data = {
                "code":controlAlgorithmCode,
                "controlCode":controlCode,
                "flowCode":flowCode,
                "polygon":polygon,
                "polygon_type": mPolygonType,
                //"extend_params":extend_params,
                "llm_code":llm_code,
                "llm_prompt":llm_prompt,
                "llm_happen_words":llm_happen_words
            }

            let handleUrl;
            if("add" === handle){
                handleUrl = "/controlAlgorithm/openAdd";
            }
            else if("edit" === handle){
                handleUrl = "/controlAlgorithm/openEdit";
            }
            else{
                return;
            }
            $.ajax({
               url: handleUrl,
               type: "post",
               async: true,
               data: data,
               dataType: "json",
               timeout: "3000",
               error: function () {
                    myToast2025("网络异常，请确定网络正常！","error",3000);
               },
               success: function (res) {
                   if(1000 === res.code){
                        myToast2025(res.msg,"success");
                        
                        // 检查是否在iframe中打开
                        if (window.parent && window.parent.closeAlgorithmModal) {
                            // 在iframe中打开，延迟关闭以显示成功消息
                            setTimeout(function() {
                                window.parent.closeAlgorithmModal();
                            }, 1000);
                        } else {
                            // 不在iframe中，跳转回布控管理页面
                            setTimeout(function() {
                                window.location.href = "/control/index";
                            }, 1000);
                        }
                   }else{
                        myToast2025(res.msg,"error",3000);
                   }
               }
            });

        }

        window.onresize = function () {
            f_adjustVideoCanvas();
        }

        function f_resetPolygon(){
            if (mPolygon !== "") {//编辑布控
                f_adjustVideoCanvas();
                
                let canvas_box_width = eleDivCanvasBox.clientWidth;
                let canvas_box_height = eleDivCanvasBox.clientHeight
                let polygon_array = mPolygon.split('#')
                let polygon_item_length = polygon_array.length
                if (mPolygonType === 1)
                {
                    option = []
                    for (let i = 0; i < polygon_item_length; i++) {
                        let item = polygon_array[i].split(",");
                        let topLx = parseInt(item[0] * canvas_box_width)
                        let topLy = parseInt(item[1] * canvas_box_height)
                        let bomRx = parseInt(item[4] * canvas_box_width)
                        let bomRy = parseInt(item[5] * canvas_box_height)
                        let topL = [topLx, topLy];
                        let bomR = [bomRx, bomRy];
                        let obj = {
                            type: 1,
                            coor: [topL, bomR]
                        }
                        option.push(obj)
                    }
                    instance.setData(option)
                }else if (mPolygonType === 2)
                {
                    if(polygon_item_length === 1){
                        option = []
                        for (let i = 0; i < polygon_item_length; i++) {
                            let item = polygon_array[i].split(",");
                            let objL = {
                                "coor": [],
                                "type": 4
                            }
                            let objLa = {
                                "coor": [],
                                "type": 6
                            }
                            for (let i = 0; i < item.length; i++) {
                                if (i % 2 === 0) {
                                    if (i > 3) {
                                        let x = item[i] * canvas_box_width
                                        let y = item[i + 1] * canvas_box_height
                                        objLa.coor.unshift([x, y])
                                    } else {
                                        let x = item[i] * canvas_box_width
                                        let y = item[i + 1] * canvas_box_height
                                        objL.coor.push([x, y])
                                    }
                                }
                            }

                            option.push(objL)
                            option.push(objLa)

                        }
                        instance.setData(option)
                    }
                }else if (mPolygonType === 3)
                {
                    option = []
                    for (let i = 0; i < polygon_item_length; i++) {
                        let item = polygon_array[i].split(",");
                        let line_count = item.length / 2;
                        let obj = {
                            type: 2,//多边形类型
                            coor: []
                        }
                        for (let j = 0; j < line_count; j++) {
                            let x = parseInt(item[j * 2] * canvas_box_width)
                            let y = parseInt(item[j * 2 + 1] * canvas_box_height)
                            obj.coor.push([x,y])
                        }
                        option.push(obj)
                    }
                    instance.setData(option)
                }
            }
        }
        $(function() {
            if(mPolygonType === 1){
                f_changeCreateType(1);
            }else if(mPolygonType === 2){
                f_changeCreateType(4);
            }else if(mPolygonType === 3){
                f_changeCreateType(2);
            }


            let wsMp4Url = "{{ controlAlgorithm.wsMp4Url }}";
            mVideoUrl = wsMp4Url;
            eleInputVideoUrl.val(mVideoUrl);
            f_playStart(mVideoUrl);
            f_adjustVideoCanvas();

            setTimeout( () =>{
                f_resetPolygon();
            }, 1200);

        });
    </script>
</body>
</html>